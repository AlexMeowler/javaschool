<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ru"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CargoAndOrdersService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Logiweb Service</a> &gt; <a href="index.source.html" class="el_package">org.retal.service</a> &gt; <span class="el_source">CargoAndOrdersService.java</span></div><h1>CargoAndOrdersService.java</h1><pre class="source lang-java linenums">package org.retal.service;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.log4j.Logger;
import org.hibernate.Session;
import org.hibernate.Transaction;
import org.retal.dao.CargoDAO;
import org.retal.dao.CityDAO;
import org.retal.dao.CityDistanceDAO;
import org.retal.dao.OrderDAO;
import org.retal.dao.OrderRouteProgressionDAO;
import org.retal.dao.RoutePointDAO;
import org.retal.dao.UserDAO;
import org.retal.domain.Car;
import org.retal.domain.Cargo;
import org.retal.domain.City;
import org.retal.domain.CityDistance;
import org.retal.domain.HibernateSessionFactory;
import org.retal.domain.Order;
import org.retal.domain.OrderRouteProgression;
import org.retal.domain.RoutePoint;
import org.retal.domain.SessionInfo;
import org.retal.domain.User;
import org.retal.domain.UserInfo;
import org.retal.domain.enums.CargoStatus;
import org.retal.domain.enums.DriverStatus;
import org.retal.domain.enums.UserRole;
import org.retal.dto.RoutePointDTO;
import org.retal.dto.RoutePointListWrapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.validation.BindingResult;
import org.springframework.validation.Validator;

/**
 * Service, containing business-logic methods regarding {@linkplain org.retal.domain.Cargo Cargo}
 * and {@linkplain org.retal.domain.Order Order} with {@linkplain org.retal.domain.RoutePoint
 * RoutePoint} entities.
 * 
 * @author Alexander Retivov
 *
 */
@Service
public class CargoAndOrdersService {

  private static final int ANNEALING_START_TEMPERAURE = 1000;
  private static final int ANNEALING_END_TEMPERATURE = 100;
  private static final int MONTH_HOURS_LIMIT = 176;
  public static final int AVERAGE_CAR_SPEED = 80;

  private final CargoDAO cargoDAO;

  private final CityDAO cityDAO;

  private final CityDistanceDAO cityDistanceDAO;

  private final OrderDAO orderDAO;

  private final UserDAO userDAO;

  private final OrderRouteProgressionDAO orderRouteProgressionDAO;

  private final CarService carService;

  private final RoutePointDAO routePointDAO;

  private final Validator cargoValidator;

  private final Validator routePointsValidator;

  private final SessionInfo sessionInfo;

<span class="fc" id="L84">  private static final Logger log = Logger.getLogger(CargoAndOrdersService.class);</span>

  /**
   * Creates an instance of this class using constructor-based dependency injection.
   */
  @Autowired
  public CargoAndOrdersService(CargoDAO cargoDAO, CityDAO cityDAO, CityDistanceDAO cityDistanceDAO,
      OrderDAO orderDAO, UserDAO userDAO, OrderRouteProgressionDAO orderRouteProgressionDAO,
      CarService carService, RoutePointDAO routePointDAO, CargoValidator cargoValidator,
<span class="fc" id="L93">      RoutePointsValidator routePointsValidator, SessionInfo sessionInfo) {</span>
<span class="fc" id="L94">    this.cargoDAO = cargoDAO;</span>
<span class="fc" id="L95">    this.cityDAO = cityDAO;</span>
<span class="fc" id="L96">    this.cityDistanceDAO = cityDistanceDAO;</span>
<span class="fc" id="L97">    this.orderDAO = orderDAO;</span>
<span class="fc" id="L98">    this.userDAO = userDAO;</span>
<span class="fc" id="L99">    this.orderRouteProgressionDAO = orderRouteProgressionDAO;</span>
<span class="fc" id="L100">    this.carService = carService;</span>
<span class="fc" id="L101">    this.routePointDAO = routePointDAO;</span>
<span class="fc" id="L102">    this.cargoValidator = cargoValidator;</span>
<span class="fc" id="L103">    this.routePointsValidator = routePointsValidator;</span>
<span class="fc" id="L104">    this.sessionInfo = sessionInfo;</span>
<span class="fc" id="L105">  }</span>

  public List&lt;Cargo&gt; getAllCargo() {
<span class="fc" id="L108">    return cargoDAO.readAll();</span>
  }

  public List&lt;Order&gt; getAllOrders() {
<span class="fc" id="L112">    return orderDAO.readAll();</span>
  }

  public Order getOrder(Integer primaryKey) {
<span class="fc" id="L116">    return orderDAO.read(primaryKey);</span>
  }

  /**
   * Checks if order has been started by drivers. Order is considered started if both statements
   * below are true:&lt;br&gt;
   * 1) it is not completed 2) car assigned has already moved from starting city or cargo has been
   * already loaded to that car
   * 
   * @param order order to check
   * @return true if order has been started, false otherwise
   */
  public boolean isOrderStarted(Order order) {
<span class="fc" id="L129">    boolean cargoChanged = false;</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">    for (Cargo cargo : order.getCargo()) {</span>
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">      cargoChanged |= !cargo.getStatus().equalsIgnoreCase(CargoStatus.PREPARED.toString());</span>
<span class="fc" id="L132">    }</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">    return !order.getIsCompleted() &amp;&amp; (!order.getCar().getLocation().getCurrentCity()</span>
<span class="pc bpc" id="L134" title="1 of 4 branches missed.">        .equals(order.getRoute().split(Order.ROUTE_DELIMETER)[0]) || cargoChanged);</span>
  }

  /**
   * Attempts to change order's assigned car to another.
   * 
   * @param data input query matching pattern &quot;A_B&quot; where A is car's registration ID and B is order
   *        ID
   * @return null if car was changed successfully, error message otherwise
   */
  public String tryToChangeOrderCar(String data) {
<span class="fc" id="L145">    Car car = null;</span>
<span class="fc" id="L146">    Order order = null;</span>
<span class="fc" id="L147">    String errorMessage = &quot;&quot;;</span>
    try {
<span class="fc" id="L149">      log.debug(data);</span>
<span class="fc" id="L150">      String[] input = data.split(&quot;_&quot;);</span>
<span class="fc" id="L151">      Integer id = Integer.parseInt(input[0]);</span>
<span class="fc" id="L152">      log.debug(id);</span>
<span class="fc" id="L153">      order = getOrder(id);</span>
<span class="fc" id="L154">      car = carService.getCar(input[1]);</span>
<span class="fc" id="L155">    } catch (Exception e) {</span>
<span class="fc" id="L156">      errorMessage = &quot;Invalid argument, please don't try to change page code.&quot;;</span>
<span class="fc" id="L157">    }</span>
<span class="fc bfc" id="L158" title="All 6 branches covered.">    if (car == null || order == null || order.getIsCompleted()) {</span>
<span class="fc" id="L159">      errorMessage = &quot;Invalid argument, please don't try to change page code.&quot;;</span>
    }
<span class="fc bfc" id="L161" title="All 2 branches covered.">    if (errorMessage.isEmpty()) {</span>
<span class="fc" id="L162">      order.setCar(car);</span>
<span class="fc" id="L163">      updateOrder(order);</span>
<span class="fc" id="L164">      return null;</span>
    } else {
<span class="fc" id="L166">      log.warn(&quot;Hacking attempt by changing page code&quot;);</span>
<span class="fc" id="L167">      return errorMessage;</span>
    }
  }

  /**
   * Updates order in database.
   * 
   * @param order order to be updated
   */
  public void updateOrder(Order order) {
<span class="fc" id="L177">    Session session = HibernateSessionFactory.getSessionFactory().openSession();</span>
<span class="fc" id="L178">    orderDAO.setSession(session);</span>
<span class="fc" id="L179">    Transaction transaction = session.beginTransaction();</span>
<span class="fc" id="L180">    orderDAO.update(order);</span>
<span class="fc" id="L181">    session.flush();</span>
<span class="fc" id="L182">    transaction.commit();</span>
<span class="fc" id="L183">    orderDAO.setSession(null);</span>
<span class="fc" id="L184">    session.close();</span>
<span class="fc" id="L185">  }</span>

  /**
   * Validates and adds new cargo row to database if validation was successful.
   * 
   * @param cargo cargo to be added
   * @param bindingResult object for storing validation result
   * @param weight input from submitted form to be parsed to integer
   */
  public void addNewCargo(Cargo cargo, BindingResult bindingResult, String weight) {
    try {
<span class="fc" id="L196">      Integer weightInt = Integer.parseInt(weight);</span>
<span class="fc" id="L197">      cargo.setMass(weightInt);</span>
<span class="fc" id="L198">    } catch (NumberFormatException e) {</span>
<span class="fc" id="L199">      bindingResult.reject(&quot;mass&quot;, &quot;Cargo weight length must be non-negative integer&quot;);</span>
<span class="fc" id="L200">    }</span>
<span class="fc" id="L201">    cargoValidator.validate(cargo, bindingResult);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">    if (!bindingResult.hasErrors()) {</span>
<span class="fc" id="L203">      cargoDAO.add(cargo);</span>
    }
<span class="fc" id="L205">  }</span>

  /**
   * Updates cargo status following chain &quot;prepared -&gt; loaded -&gt; unloaded&quot;. Additionally checks if
   * order is completed after changing cargo's status.
   * 
   * @see CargoAndOrdersService#checkOrderForCompletion(Order)
   * @param id cargo id to be updated
   * @param bindingResult object for storing validation result
   * @return true if order is completed, false otherwise
   */
  public boolean updateCargoAndCheckOrderCompletion(Integer id, BindingResult bindingResult) {
<span class="fc" id="L217">    Cargo cargo = cargoDAO.read(id);</span>
<span class="fc" id="L218">    User user = sessionInfo.getCurrentUser();</span>
<span class="fc" id="L219">    Order order = orderDAO.read(user.getUserInfo().getOrder().getId());</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">    if (cargo == null) {</span>
<span class="fc" id="L221">      bindingResult.reject(&quot;globalCargo&quot;, &quot;Cargo not found&quot;);</span>
<span class="fc" id="L222">      log.warn(&quot;Cargo not found&quot;);</span>
    } else {
<span class="fc bfc" id="L224" title="All 2 branches covered.">      if (!order.getCargo().contains(cargo)) {</span>
<span class="fc" id="L225">        bindingResult.reject(&quot;globalCargo&quot;, &quot;Attempt to change unassigned to your current&quot;</span>
            + &quot; order cargo. Please don't try to cahnge page code&quot;);
<span class="fc" id="L227">        log.warn(&quot;Attempt to access unassigned cargo&quot;);</span>
      }

    }
<span class="fc bfc" id="L231" title="All 2 branches covered.">    if (!bindingResult.hasErrors()) {</span>
<span class="fc" id="L232">      CargoStatus status = CargoStatus.valueOf(cargo.getStatus().toUpperCase());</span>
<span class="pc bpc" id="L233" title="1 of 3 branches missed.">      switch (status) {</span>
        case PREPARED:
<span class="fc" id="L235">          status = CargoStatus.LOADED;</span>
<span class="fc" id="L236">          checkCityMatch(cargo, true, bindingResult);</span>
<span class="fc" id="L237">          break;</span>
        case LOADED:
<span class="fc" id="L239">          checkCityMatch(cargo, false, bindingResult);</span>
<span class="fc" id="L240">          status = CargoStatus.UNLOADED;</span>
<span class="fc" id="L241">          break;</span>
        case UNLOADED:
        default:
          break;
      }
<span class="fc bfc" id="L246" title="All 2 branches covered.">      if (!bindingResult.hasErrors()) {</span>
<span class="fc" id="L247">        String newStatus = status.toString().toLowerCase();</span>
<span class="fc" id="L248">        log.info(&quot;Cargo id=&quot; + cargo.getId() + &quot;: changed status from &quot; + cargo.getStatus() + &quot; to &quot;</span>
            + newStatus);
<span class="fc" id="L250">        cargo.setStatus(newStatus);</span>
<span class="fc" id="L251">        cargoDAO.update(cargo);</span>
<span class="fc" id="L252">        return checkOrderForCompletion(order);</span>
      }
    }
<span class="fc" id="L255">    return false;</span>
  }

  /**
   * Checks order for completion.
   * 
   * @param order order to be checked
   * @return true if order is completed, false otherwise
   */
  private boolean checkOrderForCompletion(Order order) {
<span class="fc" id="L265">    boolean isCompleted = true;</span>
<span class="fc" id="L266">    order = orderDAO.read(order.getId());</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">    for (Cargo c : order.getCargo()) {</span>
<span class="fc" id="L268">      log.debug(c.getStatus());</span>
<span class="fc" id="L269">      isCompleted &amp;= c.getStatus().equalsIgnoreCase(CargoStatus.UNLOADED.toString());</span>
<span class="fc" id="L270">    }</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">    if (isCompleted) {</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">      for (UserInfo driverInfo : order.getDriverInfo()) {</span>
<span class="fc" id="L273">        log.debug(driverInfo.getUser().toString());</span>
<span class="fc" id="L274">        driverInfo.setOrder(null);</span>
<span class="fc" id="L275">        driverInfo.setCar(null);</span>
<span class="fc" id="L276">        driverInfo.setHoursDrived(null);</span>
<span class="fc" id="L277">        userDAO.update(driverInfo.getUser());</span>
<span class="fc" id="L278">      }</span>
<span class="fc" id="L279">      orderRouteProgressionDAO.delete(order.getOrderRouteProgression());</span>
<span class="fc" id="L280">      order.setIsCompleted(isCompleted);</span>
<span class="fc" id="L281">      order.setCar(null);</span>
<span class="fc" id="L282">      Session session = HibernateSessionFactory.getSessionFactory().openSession();</span>
<span class="fc" id="L283">      orderDAO.setSession(session);</span>
<span class="fc" id="L284">      Transaction transaction = session.beginTransaction();</span>
<span class="fc" id="L285">      orderDAO.update(order);</span>
<span class="fc" id="L286">      session.flush();</span>
<span class="fc" id="L287">      transaction.commit();</span>
<span class="fc" id="L288">      orderDAO.setSession(null);</span>
<span class="fc" id="L289">      session.close();</span>
<span class="fc" id="L290">      sessionInfo.refreshUser();</span>
    }
<span class="fc" id="L292">    return isCompleted;</span>
  }

  /**
   * Checks if city where the driver is matches the city to load/unload cargo.
   * 
   * @param cargo {@linkplain org.retal.domain.Cargo Cargo} to be loaded/unloaded
   * @param isLoading true if we are looking for match between city of load and current location,
   *        false if we are looking for match between city of unload and current location
   * @param bindingResult object to store validation errors
   */
  private void checkCityMatch(Cargo cargo, boolean isLoading, BindingResult bindingResult) {
<span class="fc" id="L304">    User driver = sessionInfo.getCurrentUser();</span>
<span class="fc" id="L305">    RoutePoint point = cargo.getPoints().stream().filter(c -&gt; c.getIsLoading().equals(isLoading))</span>
<span class="fc" id="L306">        .collect(Collectors.toList()).get(0);</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">    if (!point.getCity().equals(driver.getUserInfo().getCity())) {</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">      String action = isLoading ? &quot;load&quot; : &quot;unload&quot;;</span>
<span class="fc" id="L309">      bindingResult.reject(&quot;cityNotMatching&quot;, &quot;You must be in &quot; + point.getCity().getCurrentCity()</span>
<span class="fc" id="L310">          + &quot; to &quot; + action + &quot; cargo \&quot;&quot; + cargo.getName() + &quot;\&quot;&quot;);</span>
    }
<span class="fc" id="L312">  }</span>

  /**
   * Maps list of {@linkplain org.retal.dto.RoutePointDTO RoutePointDTOs} to list of
   * {@linkplain org.retal.domain.RoutePoint RoutePoints}.
   * 
   * @param list of {@linkplain org.retal.dto.RoutePointDTO RoutePointDTOs} to be mapped
   * @return list of {@linkplain org.retal.domain.RoutePoint RoutePoints}
   */
  public List&lt;RoutePoint&gt; mapRoutePointDTOsToEntities(List&lt;RoutePointDTO&gt; list) {
<span class="fc" id="L322">    List&lt;RoutePoint&gt; entityList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">    for (RoutePointDTO rpDTO : list) {</span>
<span class="fc" id="L324">      RoutePoint rp = new RoutePoint();</span>
<span class="fc" id="L325">      rp.setIsLoading(rpDTO.getIsLoading());</span>
<span class="fc" id="L326">      rp.setCity(cityDAO.read(rpDTO.getCityName()));</span>
<span class="fc" id="L327">      rp.setCargo(cargoDAO.read(rpDTO.getCargoId()));</span>
<span class="fc" id="L328">      entityList.add(rp);</span>
<span class="fc" id="L329">    }</span>
<span class="fc" id="L330">    return entityList;</span>
  }

  /**
   * Validates {@linkplain org.retal.domain.RoutePoint RoutePoint} input and if no errors found,
   * attempts to calculate optimal path and assign car and drivers according to that path. If path,
   * car and drivers are selected, then {@linkplain org.retal.domain.Order Order} is created and
   * saved to database.
   * 
   * @param wrapper {@linkplain org.retal.dto.RoutePointListWrapper wrapper} for list of route
   *        points to be validated and used for order creation
   * @param bindingResult object for storing validation result
   */
  public void createOrderAndRoutePoints(RoutePointListWrapper wrapper,
      BindingResult bindingResult) {
<span class="fc" id="L345">    routePointsValidator.validate(wrapper, bindingResult);</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">    if (!bindingResult.hasErrors()) {</span>
<span class="fc" id="L347">      List&lt;RoutePoint&gt; list = mapRoutePointDTOsToEntities(wrapper.getList());</span>
<span class="fc" id="L348">      log.info(&quot;Mapped &quot; + list.size() + &quot; DTOs to entities&quot;);</span>
<span class="fc" id="L349">      List&lt;CityDistance&gt; distances = cityDistanceDAO.readAll();</span>
<span class="fc" id="L350">      List&lt;City&gt; cities = cityDAO.readAll();</span>
<span class="fc" id="L351">      Set&lt;RoutePoint&gt; points = new HashSet&lt;&gt;(list);</span>
<span class="fc" id="L352">      Object[] carAndDriversAndPath =</span>
<span class="fc" id="L353">          findAppropriateCarAndDriversAndCalculatePath(list, distances, cities);</span>
<span class="fc" id="L354">      Car selectedCar = (Car) carAndDriversAndPath[0];</span>
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L356">      List&lt;User&gt; drivers = (List&lt;User&gt;) carAndDriversAndPath[1];</span>
<span class="fc" id="L357">      String route = (String) carAndDriversAndPath[2];</span>
<span class="fc" id="L358">      Float requiredCapacity = (Float) carAndDriversAndPath[3];</span>
      // i don't know if this will ever be triggered because if route hadn't been calculated
      // then algorithm would have been in an infinite loop
<span class="pc bpc" id="L361" title="2 of 4 branches missed.">      if (route == null || route.isEmpty()) {</span>
<span class="nc" id="L362">        bindingResult.reject(&quot;globalRoute&quot;, &quot;Could not calculate route.&quot;);</span>
      } else {
<span class="fc bfc" id="L364" title="All 2 branches covered.">        if (selectedCar == null) {</span>
<span class="fc" id="L365">          bindingResult.reject(&quot;globalCar&quot;,</span>
              &quot;Could not select car. Please make sure there is&quot; + &quot; working car in &quot;
<span class="fc" id="L367">                  + route.split(Order.ROUTE_DELIMETER)[0] + &quot; which has capacity of &quot;</span>
                  + requiredCapacity + &quot; tons.&quot;);
        }
<span class="fc bfc" id="L370" title="All 2 branches covered.">        if (drivers == null) {</span>
<span class="fc" id="L371">          bindingResult.reject(&quot;globalDrivers&quot;,</span>
              &quot;Could not select drivers. Please make sure there are&quot;
<span class="fc" id="L373">                  + &quot; available drivers on route &quot; + route.replace(Order.ROUTE_DELIMETER, &quot;-&gt;&quot;)</span>
                  + &quot;.&quot;);
        }
      }
<span class="fc bfc" id="L377" title="All 2 branches covered.">      if (!bindingResult.hasErrors()) {</span>
<span class="fc" id="L378">        Session session = HibernateSessionFactory.getSessionFactory().openSession();</span>
<span class="fc" id="L379">        Order order = new Order();</span>
<span class="fc" id="L380">        order.setCar(selectedCar);</span>
<span class="fc" id="L381">        order.setPoints(points);</span>
<span class="fc" id="L382">        order.setRoute(route);</span>
<span class="fc" id="L383">        order.setIsCompleted(false);</span>
<span class="fc" id="L384">        order.setRequiredCapacity(requiredCapacity);</span>
<span class="fc" id="L385">        order.setRequiredShiftLength(selectedCar.getShiftLength());</span>
<span class="fc" id="L386">        Transaction transaction = session.beginTransaction();</span>
<span class="fc" id="L387">        orderDAO.setSession(session);</span>
<span class="fc" id="L388">        orderDAO.add(order);</span>
<span class="fc" id="L389">        transaction.commit();</span>
<span class="fc" id="L390">        transaction = session.beginTransaction();</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">        for (User driver : drivers) {</span>
<span class="fc" id="L392">          driver.getUserInfo().setOrder(order);</span>
<span class="fc" id="L393">          userDAO.update(driver);</span>
<span class="fc" id="L394">        }</span>
<span class="fc" id="L395">        routePointDAO.setSession(session);</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">        for (RoutePoint rp : points) {</span>
<span class="fc" id="L397">          rp.setOrder(order);</span>
<span class="fc" id="L398">          routePointDAO.add(rp);</span>
<span class="fc" id="L399">        }</span>
<span class="fc" id="L400">        transaction.commit();</span>
<span class="fc" id="L401">        orderDAO.setSession(null);</span>
<span class="fc" id="L402">        routePointDAO.setSession(null);</span>
<span class="fc" id="L403">        session.close();</span>
<span class="fc" id="L404">        OrderRouteProgression orderRouteProgression = new OrderRouteProgression();</span>
<span class="fc" id="L405">        orderRouteProgression.setOrder(order);</span>
<span class="fc" id="L406">        orderRouteProgression.setRouteCounter(0);</span>
<span class="fc" id="L407">        orderRouteProgressionDAO.add(orderRouteProgression);</span>
      }
    }
<span class="fc" id="L410">  }</span>

  /**
   * Calculates optimal path and attempts to select car and drivers to complete the order. Optimal
   * path calculation is basically solving the &quot;Traveling Salesman Problem&quot; with additional
   * restrictions, such as:&lt;br&gt;
   * City of unloading for cargo X can not be visited before city of loading for cargo X; &lt;br&gt;
   * Only loading cities can be starting points; &lt;br&gt;
   * Avoid starting from city cycles (that means that city X is city both for loading and unloading
   * come cargo) at all costs;&lt;br&gt;
   * In common case we have open version of TSP (no need to return back to starting city), if not
   * specified directly. &lt;br&gt;
   * All restrictions above are based on three reasons: 1) to avoid infinite loops during
   * calculation 2) to make found routes applicable to the cause 3) to save extra time (the guesses
   * are hypothetical and not proved mathematically)
   * 
   * @see &lt;a href=&quot;https://en.wikipedia.org/wiki/Traveling_salesman_problem&quot;&gt;Traveling salesman
   *      problem&lt;/a&gt;
   * @param list list of {@linkplain org.retal.domain.RoutePoint RoutePoint} entities
   * @param distances list of all {@linkplain org.retal.domain.CityDistance CityDistance} entities
   *        from database
   * @param cities list of all {@linkplain org.retal.domain.City City} entities.
   * @return Object array of size 3: Object[0] is selected {@linkplain org.retal.domain.Car Car},
   *         Object[1] is List&lt;{@linkplain org.retal.domain.User User} (selected drivers), Object[3]
   *         is String (shortest path, cities are divided by &quot;;&quot;), Object[4] is Float (required
   *         capacity, used in showing error message). Path and required capacity are never null.
   */
  public Object[] findAppropriateCarAndDriversAndCalculatePath(List&lt;RoutePoint&gt; list,
      List&lt;CityDistance&gt; distances, List&lt;City&gt; cities) {
<span class="fc" id="L439">    log.info(&quot;Searching for cars and paths...&quot;);</span>
<span class="fc" id="L440">    Set&lt;City&gt; allRoutePointCities = new HashSet&lt;&gt;();</span>
<span class="fc" id="L441">    List&lt;String&gt; cityNames =</span>
<span class="fc" id="L442">        cities.stream().map(c -&gt; c.getCurrentCity()).collect(Collectors.toList());</span>
<span class="fc" id="L443">    log.debug(&quot;Mapped city names&quot;);</span>
<span class="fc" id="L444">    List&lt;Integer&gt; loadingCities = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L445">    List&lt;Integer&gt; unloadingCities = new ArrayList&lt;&gt;();</span>
    // adding all unique cities to set
<span class="fc bfc" id="L447" title="All 2 branches covered.">    for (RoutePoint rp : list) {</span>
<span class="fc" id="L448">      allRoutePointCities.add(rp.getCity());</span>
<span class="fc" id="L449">    }</span>
<span class="fc" id="L450">    List&lt;City&gt; rpCities = new ArrayList&lt;&gt;(allRoutePointCities);</span>
    // filling two lists with city indexes for loading and unloading cargo indexed i
<span class="fc bfc" id="L452" title="All 2 branches covered.">    for (RoutePoint rp : list) {</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">      if (rp.getIsLoading()) {</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">        for (RoutePoint rp2 : list) {</span>
<span class="fc bfc" id="L455" title="All 4 branches covered.">          if (!rp2.getIsLoading() &amp;&amp; rp2.getCargo().getId() == rp.getCargo().getId()) {</span>
<span class="fc" id="L456">            loadingCities.add(rpCities.indexOf(rp.getCity()));</span>
<span class="fc" id="L457">            unloadingCities.add(rpCities.indexOf(rp2.getCity()));</span>
          }
<span class="fc" id="L459">        }</span>
      }
<span class="fc" id="L461">    }</span>
<span class="fc" id="L462">    String t = &quot;&quot;;</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">    for (City c : rpCities) {</span>
<span class="fc" id="L464">      t += c.getCurrentCity() + &quot; &quot;;</span>
<span class="fc" id="L465">    }</span>
<span class="fc" id="L466">    log.debug(t);</span>
<span class="fc" id="L467">    log.debug(loadingCities.toString());</span>
<span class="fc" id="L468">    log.debug(unloadingCities.toString());</span>
    // maps for calculating optimal route for all cities which can be start points
<span class="fc" id="L470">    Map&lt;String, Integer&gt; optimalRoutes = new HashMap&lt;&gt;();</span>
<span class="fc" id="L471">    Map&lt;String, int[][]&gt; optimalRoutesMatrixes = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L472" title="All 2 branches covered.">    for (RoutePoint rp : list) {</span>
      // only loading cities can be starting points to save time(it is my heuristic hypothesis)
<span class="fc bfc" id="L474" title="All 2 branches covered.">      if (rp.getIsLoading()) {</span>
<span class="fc" id="L475">        log.debug(rp.getCity().getCurrentCity());</span>
        // getting load and unload indexes, if current city is only loading/unloading
        // then we can calculate optimal route starting from this city
        // otherwise it is a &quot;cycle&quot; and we skip it
<span class="fc" id="L479">        int loadIndex = loadingCities.indexOf(rpCities.indexOf(rp.getCity()));</span>
<span class="fc" id="L480">        int unloadIndex = unloadingCities.indexOf(rpCities.indexOf(rp.getCity()));</span>
<span class="pc bpc" id="L481" title="1 of 4 branches missed.">        if (loadIndex == -1 || unloadIndex == -1) {</span>
          // build matrix for traveling between cities
<span class="fc" id="L483">          int n = cities.size();</span>
<span class="fc" id="L484">          int[][] bigMatrix = buildMatrix(n);</span>
<span class="fc" id="L485">          fillMatrixWithDefaultCityDistances(bigMatrix, distances, cityNames);</span>
<span class="fc" id="L486">          log.debug(&quot;Filled big matrix&quot;);</span>
<span class="fc" id="L487">          n = rpCities.size();</span>
<span class="fc" id="L488">          int[][] matrix = buildMatrix(n);</span>
          // calculate paths for cities which are not connected directly in real life.
          // this is used to make our graph full (i.e. all cities are connected to each other).
<span class="fc" id="L491">          resolvePathsForMatrix(matrix, bigMatrix, cityNames, rpCities);</span>
<span class="fc" id="L492">          log.info(&quot;Calculating optimized route (annealing algorithm)...&quot;);</span>
          // simulated annealing algorithm is used for calculating path
<span class="fc" id="L494">          int[] annealing = findOptimalPathUsingAnnealingImitation(matrix,</span>
<span class="fc" id="L495">              ANNEALING_START_TEMPERAURE, ANNEALING_END_TEMPERATURE, rpCities.indexOf(rp.getCity()),</span>
              loadingCities, unloadingCities, false);
<span class="fc" id="L497">          String route = &quot;&quot;;</span>
<span class="fc" id="L498">          int length = 0;</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">          for (int path : annealing) {</span>
<span class="fc" id="L500">            route += rpCities.get(path).getCurrentCity() + &quot; &quot;;</span>
          }
<span class="fc" id="L502">          length = 0;</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">          for (int i = 0; i &lt; annealing.length - 1; i++) {</span>
<span class="fc" id="L504">            length += matrix[annealing[i]][annealing[i + 1]];</span>
          }
<span class="fc" id="L506">          log.debug(&quot;Suggested route - &quot; + route + &quot;; it's length - &quot; + length);</span>
<span class="fc" id="L507">          optimalRoutes.put(route, length);</span>
<span class="fc" id="L508">          optimalRoutesMatrixes.put(route, matrix);</span>
<span class="fc" id="L509">        } else {</span>
<span class="fc" id="L510">          log.debug(&quot;Cycle detected&quot;);</span>
        }
      }
<span class="fc" id="L513">    }</span>
    // if we have full cycle (i.e. each city is both city of loading and unloading come cargo)
    // for example:
    // cargo 1 - load in A; drop in B
    // cargo 2 - load in B; drop in A
    // in this case we don't care about restrictions above, so we try to find optimal path
    // starting from each city
    // but technically they will be all the same due to loop
<span class="fc bfc" id="L521" title="All 2 branches covered.">    if (optimalRoutes.size() == 0) {</span>
<span class="fc" id="L522">      log.debug(&quot;Did not find optimal route without cycles&quot;);</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">      for (RoutePoint rp : list) {</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">        if (rp.getIsLoading()) {</span>
<span class="fc" id="L525">          int loadIndex = loadingCities.indexOf(rpCities.indexOf(rp.getCity()));</span>
<span class="fc" id="L526">          int unloadIndex = unloadingCities.indexOf(rpCities.indexOf(rp.getCity()));</span>
<span class="pc bpc" id="L527" title="2 of 4 branches missed.">          if (loadIndex != -1 &amp;&amp; unloadIndex != -1) {</span>
            // build matrix for traveling between cities
<span class="fc" id="L529">            int n = cities.size();</span>
<span class="fc" id="L530">            int[][] bigMatrix = buildMatrix(n);</span>
<span class="fc" id="L531">            fillMatrixWithDefaultCityDistances(bigMatrix, distances, cityNames);</span>
<span class="fc" id="L532">            log.debug(&quot;Filled big matrix&quot;);</span>
<span class="fc" id="L533">            n = rpCities.size();</span>
<span class="fc" id="L534">            int[][] matrix = buildMatrix(n);</span>
            // calculate paths for cities which are not connected directly in real life;
            // this is used to make our graph full (i.e. all cities are connected to each other)
<span class="fc" id="L537">            resolvePathsForMatrix(matrix, bigMatrix, cityNames, rpCities);</span>
<span class="fc" id="L538">            log.info(&quot;Calculating optimized route for cycle (annealing algorithm)...&quot;);</span>
<span class="fc" id="L539">            int[] annealingPaths = findOptimalPathUsingAnnealingImitation(matrix,</span>
                ANNEALING_START_TEMPERAURE, ANNEALING_END_TEMPERATURE,
<span class="fc" id="L541">                rpCities.indexOf(rp.getCity()), loadingCities, unloadingCities, true);</span>
<span class="fc" id="L542">            String path = &quot;&quot;;</span>
<span class="fc" id="L543">            int length = 0;</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">            for (int x : annealingPaths) {</span>
<span class="fc" id="L545">              path += rpCities.get(x).getCurrentCity() + &quot; &quot;;</span>
            }
<span class="fc" id="L547">            length = 0;</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">            for (int i = 0; i &lt; annealingPaths.length - 1; i++) {</span>
<span class="fc" id="L549">              length += matrix[annealingPaths[i]][annealingPaths[i + 1]];</span>
            }
<span class="fc" id="L551">            log.debug(&quot;Suggested route - &quot; + path + &quot;; it's length - &quot; + length);</span>
<span class="fc" id="L552">            optimalRoutes.put(path, length);</span>
<span class="fc" id="L553">            optimalRoutesMatrixes.put(path, matrix);</span>
          }
        }
<span class="fc" id="L556">      }</span>
    }
    // now we have to find the shortest optimal route
<span class="fc" id="L559">    String shortestPath = &quot;&quot;;</span>
<span class="fc" id="L560">    int shortestPathLength = Integer.MAX_VALUE;</span>
<span class="fc" id="L561">    int[][] shortestPathMatrix = null;</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">    for (Map.Entry&lt;String, Integer&gt; e : optimalRoutes.entrySet()) {</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">      if (e.getValue() &lt; shortestPathLength) {</span>
<span class="fc" id="L564">        shortestPath = e.getKey();</span>
<span class="fc" id="L565">        shortestPathLength = e.getValue();</span>
<span class="fc" id="L566">        shortestPathMatrix = optimalRoutesMatrixes.get(shortestPath);</span>
      }
<span class="fc" id="L568">    }</span>
    // calculating required capacity when following path
<span class="fc" id="L570">    String[] shortestPathCities = shortestPath.split(&quot; &quot;);</span>
<span class="fc" id="L571">    float requiredCapacity = 0;</span>
<span class="fc" id="L572">    float currentCapacity = 0;</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">    for (RoutePoint rp : list) {</span>
<span class="fc bfc" id="L574" title="All 4 branches covered.">      if (rp.getCity().getCurrentCity().equals(shortestPathCities[0]) &amp;&amp; rp.getIsLoading()) {</span>
<span class="fc" id="L575">        currentCapacity = currentCapacity + rp.getCargo().getMass();</span>
      }
<span class="fc" id="L577">    }</span>
<span class="fc" id="L578">    requiredCapacity = currentCapacity;</span>
<span class="fc" id="L579">    log.debug(&quot;Starting capacity(kg) - &quot; + requiredCapacity);</span>
<span class="fc bfc" id="L580" title="All 2 branches covered.">    for (int i = 1; i &lt; shortestPathCities.length - 1; i++) {</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">      for (RoutePoint rp : list) {</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">        if (rp.getCity().getCurrentCity().equals(shortestPathCities[i])) {</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">          int sign = rp.getIsLoading() ? 1 : -1;</span>
<span class="fc" id="L584">          currentCapacity = currentCapacity + sign * rp.getCargo().getMass();</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">          if (currentCapacity &gt; requiredCapacity) {</span>
<span class="fc" id="L586">            requiredCapacity = currentCapacity;</span>
          }
        }
<span class="fc" id="L589">      }</span>
    }
<span class="fc" id="L591">    requiredCapacity /= 1000;</span>
<span class="fc" id="L592">    log.debug(&quot;Required capacity - &quot; + requiredCapacity + &quot; tons&quot;);</span>
<span class="fc" id="L593">    String firstCity = shortestPath.split(&quot; &quot;)[0];</span>
    // calculate drivers for all possible cars
<span class="fc" id="L595">    List&lt;Car&gt; selectedCarList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L596">    List&lt;List&lt;User&gt;&gt; selectedDriversList = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">    for (City city : rpCities) {</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">      if (city.getCurrentCity().equals(firstCity)) {</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">        for (Car car : city.getCars()) {</span>
<span class="fc" id="L600">          List&lt;User&gt; drivers =</span>
<span class="fc" id="L601">              tryToAssignDriversForOrder(shortestPath, shortestPathMatrix, rpCities, car);</span>
<span class="pc bpc" id="L602" title="1 of 4 branches missed.">          if (car.getOrder() == null &amp;&amp; car.getIsWorking()</span>
<span class="pc bpc" id="L603" title="2 of 4 branches missed.">              &amp;&amp; car.getCapacityTons() &gt;= requiredCapacity &amp;&amp; drivers != null) {</span>
<span class="fc" id="L604">            selectedCarList.add(car);</span>
<span class="fc" id="L605">            selectedDriversList.add(drivers);</span>
<span class="fc" id="L606">            break;</span>
          }
<span class="fc" id="L608">        }</span>
<span class="fc" id="L609">        break;</span>
      }
<span class="fc" id="L611">    }</span>
    // selecting car with minimal fitting capacity
<span class="fc" id="L613">    log.debug(&quot;Matching cars: &quot; + selectedCarList.toString());</span>
<span class="fc" id="L614">    Car selectedCar = selectedCarList.stream()</span>
<span class="pc" id="L615">        .min((a, b) -&gt; (int) (a.getCapacityTons() - b.getCapacityTons())).orElse(null);</span>
<span class="fc" id="L616">    List&lt;User&gt; selectedDrivers = null;</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">    if (selectedCar != null) {</span>
<span class="fc" id="L618">      selectedDrivers = selectedDriversList.get(selectedCarList.indexOf(selectedCar));</span>
    }
<span class="fc" id="L620">    shortestPath = shortestPath.replace(&quot; &quot;, Order.ROUTE_DELIMETER);</span>
<span class="fc" id="L621">    shortestPath = shortestPath.substring(0, shortestPath.length() - 1);</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">    String driversMessage = selectedDrivers != null ? selectedDrivers.toString() : &quot;null&quot;;</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">    String carMessage = selectedCar != null ? selectedCar.toString() : &quot;null&quot;;</span>
<span class="fc" id="L624">    log.debug(&quot;Selected drivers, car and route - &quot; + driversMessage + &quot;; &quot; + carMessage + &quot;; &quot;</span>
        + shortestPath);
<span class="fc" id="L626">    return new Object[] {selectedCar, selectedDrivers, shortestPath, requiredCapacity};</span>
  }

  /**
   * Calculates distance between two cities.
   * 
   * @param cityA first city
   * @param cityB second city
   * @return distance between cityA and cityB
   */
  public int lengthBetweenTwoCities(String cityA, String cityB) {
<span class="fc" id="L637">    List&lt;City&gt; cities = cityDAO.readAll();</span>
<span class="fc" id="L638">    List&lt;String&gt; cityNames =</span>
<span class="fc" id="L639">        cities.stream().map(c -&gt; c.getCurrentCity()).collect(Collectors.toList());</span>
<span class="fc" id="L640">    int n = cities.size();</span>
<span class="fc" id="L641">    int[][] bigMatrix = buildMatrix(n);</span>
<span class="fc" id="L642">    List&lt;CityDistance&gt; distances = cityDistanceDAO.readAll();</span>
<span class="fc" id="L643">    fillMatrixWithDefaultCityDistances(bigMatrix, distances, cityNames);</span>
<span class="fc" id="L644">    List&lt;City&gt; inputCities =</span>
<span class="fc" id="L645">        Stream.of(cityDAO.read(cityA), cityDAO.read(cityB)).collect(Collectors.toList());</span>
<span class="fc" id="L646">    n = inputCities.size();</span>
<span class="fc" id="L647">    int[][] matrix = buildMatrix(n);</span>
<span class="fc" id="L648">    resolvePathsForMatrix(matrix, bigMatrix, cityNames, inputCities);</span>
<span class="fc" id="L649">    return matrix[0][1];</span>
  }

  /**
   * Implementation of Dijkstra algorithm to find shortest path between to vertices in graph. Used
   * for calculating paths between cities which are not connected directly.
   * 
   * @param matr matrix of distances between cities
   * @param result list which will store shortest path indexes
   * @param from index of city to start from
   * @param to index of city to end at
   * @return distance length, path is stored in &lt;b&gt;result&lt;/b&gt; variable
   */
  private int getShortestPath(int[][] matr, List&lt;Integer&gt; result, int from, int to) {
<span class="fc" id="L663">    int n = matr.length;</span>
<span class="fc" id="L664">    final int MAX = Integer.MAX_VALUE / 2;</span>
<span class="fc" id="L665">    int[] weights = new int[n];</span>
<span class="fc" id="L666">    boolean[] visited = new boolean[n];</span>
<span class="fc" id="L667">    Arrays.fill(weights, MAX);</span>
<span class="fc" id="L668">    weights[from] = 0;</span>
<span class="fc" id="L669">    boolean allVisited = false;</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">    while (!allVisited) {</span>
<span class="fc" id="L671">      int min = MAX;</span>
<span class="fc" id="L672">      int current = 0;</span>
<span class="fc bfc" id="L673" title="All 2 branches covered.">      for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L674" title="All 4 branches covered.">        if (!visited[i] &amp;&amp; weights[i] &lt; min) {</span>
<span class="fc" id="L675">          min = weights[i];</span>
<span class="fc" id="L676">          current = i;</span>
        }
      }
<span class="fc bfc" id="L679" title="All 2 branches covered.">      for (int i = 1; i &lt; n; i++) {</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">        if (matr[current][i] != MAX) {</span>
<span class="fc" id="L681">          weights[i] = Math.min(weights[i], weights[current] + matr[current][i]);</span>
        }
      }
<span class="fc" id="L684">      visited[current] = true;</span>
<span class="fc" id="L685">      allVisited = true;</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">      for (boolean flag : visited) {</span>
<span class="fc" id="L687">        allVisited &amp;= flag;</span>
      }
<span class="fc" id="L689">    }</span>
<span class="fc" id="L690">    log.debug(&quot;Dijkstra: visited all cities; distance is &quot; + weights[to]);</span>
<span class="fc" id="L691">    int current = to;</span>
<span class="fc bfc" id="L692" title="All 2 branches covered.">    while (current != from) {</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">      for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L694" title="All 2 branches covered.">        if (weights[current] - matr[i][current] == weights[i]) {</span>
<span class="fc" id="L695">          result.add(current);</span>
<span class="fc" id="L696">          current = i;</span>
        }
      }
    }
<span class="fc" id="L700">    return weights[to];</span>
  }

  /**
   * Simulated annealing algorithm implementation for solving the traveling salesman problem. This
   * is modified version of algorithm based on some restrictions stated
   * {@linkplain #createOrderAndRoutePoints(RoutePointListWrapper, BindingResult) here}
   * 
   * @see &lt;a href=&quot;https://en.wikipedia.org/wiki/Simulated_annealing&quot;&gt;Simulated annealing
   *      algorithm&lt;/a&gt;
   * @param matr matrix of distances between cities
   * @param initialTemperature temperature at which annealing starts
   * @param endTemperature temperature at which annealing ends
   * @param from city index to start from
   * @param loadingCities cities of loading cargo
   * @param unloadingCities cities of unloading cargo
   * @param cycleDetected flag if suggested path has cycles
   * @return array of city indexes containing optimal path
   */
  private int[] findOptimalPathUsingAnnealingImitation(int[][] matr, double initialTemperature,
      double endTemperature, int from, List&lt;Integer&gt; loadingCities, List&lt;Integer&gt; unloadingCities,
      boolean cycleDetected) {
<span class="fc" id="L722">    int n = matr.length;</span>
    // lack of cycle for starting city doesn't guarantee there are no cycles
    // for example 3-1-4-5-1 : oops
<span class="fc bfc" id="L725" title="All 2 branches covered.">    if (!cycleDetected) {</span>
<span class="fc" id="L726">      log.debug(&quot;Annealing: pre-checking for possible cycle&quot;);</span>
<span class="fc" id="L727">      boolean[] visited = new boolean[n];</span>
<span class="fc" id="L728">      int i = from;</span>
<span class="fc bfc" id="L729" title="All 4 branches covered.">      while (!visited[i] &amp;&amp; loadingCities.indexOf(i) != -1) {</span>
<span class="fc" id="L730">        visited[i] = true;</span>
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">        if (loadingCities.indexOf(i) != -1) {</span>
<span class="fc" id="L732">          i = unloadingCities.get(loadingCities.indexOf(i));</span>
<span class="fc bfc" id="L733" title="All 2 branches covered.">          if (loadingCities.indexOf(i) == -1) {</span>
<span class="fc" id="L734">            int counter = 0;</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">            for (int j = 0; j &lt; visited.length; j++) {</span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">              counter = !visited[j] ? counter + 1 : counter;</span>
              /*if (!visited[j]) {
                counter++;
              }*/
            }
<span class="fc bfc" id="L741" title="All 2 branches covered.">            if (counter &gt; 1) {</span>
<span class="fc" id="L742">              visited[i] = true;</span>
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">              for (int j = 0; j &lt; visited.length; j++) {</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">                if (!visited[j]) {</span>
<span class="fc" id="L745">                  i = j;</span>
<span class="fc" id="L746">                  break;</span>
                }
              }
            }
<span class="fc" id="L750">          }</span>
        }
      }
<span class="fc bfc" id="L753" title="All 2 branches covered.">      if (visited[i]) {</span>
<span class="fc" id="L754">        log.debug(&quot;Possible cycle detected&quot;);</span>
<span class="fc" id="L755">        cycleDetected = true;</span>
      }
    }
    // if we have cycle in our path, we need to check if its one big cycle or set of different
    // cycles
<span class="fc bfc" id="L760" title="All 2 branches covered.">    if (cycleDetected) {</span>
<span class="fc" id="L761">      log.debug(&quot;Annealing: Trying to define cycle type&quot;);</span>
<span class="fc" id="L762">      boolean[] visited = new boolean[n];</span>
<span class="fc" id="L763">      int[] answer = new int[n + 1];</span>
<span class="fc" id="L764">      Arrays.fill(answer, -1);</span>
<span class="fc" id="L765">      int k = 0;</span>
<span class="fc" id="L766">      int i = from;</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">      while (!visited[i]) {</span>
<span class="fc" id="L768">        visited[i] = true;</span>
<span class="fc" id="L769">        answer[k] = i;</span>
<span class="fc" id="L770">        k++;</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">        if (loadingCities.indexOf(i) != -1) {</span>
<span class="fc" id="L772">          i = unloadingCities.get(loadingCities.indexOf(i));</span>
        } else {
<span class="fc" id="L774">          int index = unloadingCities.indexOf(i);</span>
<span class="fc" id="L775">          int x = loadingCities.get(index);</span>
<span class="fc bfc" id="L776" title="All 2 branches covered.">          for (int j = 0; j &lt; loadingCities.size(); j++) {</span>
<span class="pc bpc" id="L777" title="1 of 4 branches missed.">            if (loadingCities.get(j) == x &amp;&amp; j != index) {</span>
<span class="nc" id="L778">              i = x;</span>
<span class="nc" id="L779">              int[] buffer = new int[answer.length + 1];</span>
<span class="nc" id="L780">              System.arraycopy(answer, 0, buffer, 0, k);</span>
<span class="nc" id="L781">              answer = buffer;</span>
<span class="nc" id="L782">              visited[i] = false;</span>
<span class="nc" id="L783">              break;</span>
            }
          }
<span class="fc" id="L786">        }</span>
        // log.debug(Arrays.toString(answer));
      }
<span class="fc" id="L789">      boolean allVisited = true;</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">      for (boolean flag : visited) {</span>
<span class="fc" id="L791">        allVisited &amp;= flag;</span>
      }
<span class="fc bfc" id="L793" title="All 2 branches covered.">      if (allVisited) {</span>
<span class="fc" id="L794">        log.debug(&quot;Annealing: Full cycle detected - only one possible route&quot;);</span>
<span class="fc" id="L795">        answer[answer.length - 1] = i;</span>
<span class="fc" id="L796">        return answer;</span>
      }
    }
<span class="fc" id="L799">    List&lt;Integer&gt; routeList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L800" title="All 2 branches covered.">    for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L801">      routeList.add(i);</span>
    }
<span class="fc" id="L803">    Collections.shuffle(routeList);</span>
<span class="fc" id="L804">    int valueIndex = routeList.indexOf(from);</span>
<span class="fc" id="L805">    routeList.set(valueIndex, routeList.get(0));</span>
<span class="fc" id="L806">    routeList.set(0, from);</span>
    // in case of set of cycles we have to go back to some cities to deliver cargo
<span class="fc bfc" id="L808" title="All 2 branches covered.">    if (cycleDetected) {</span>
<span class="fc" id="L809">      log.debug(&quot;Annealing: Set of cycles detected - editing entry candidate&quot;);</span>
<span class="fc" id="L810">      adaptCandidateForCycleProcessing(routeList, loadingCities, unloadingCities);</span>
<span class="fc" id="L811">      n = routeList.size();</span>
    }
<span class="fc" id="L813">    Object[] obj = routeList.toArray();</span>
<span class="fc" id="L814">    int[] route = new int[n];</span>
<span class="fc bfc" id="L815" title="All 2 branches covered.">    for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L816">      route[i] = (Integer) obj[i];</span>
    }
<span class="fc" id="L818">    double currentTemperature = initialTemperature;</span>
<span class="fc" id="L819">    int currentEnergy = calculateEnergy(route, matr);</span>
<span class="fc" id="L820">    int k = 1;</span>
<span class="fc" id="L821">    n = matr.length;</span>
<span class="fc" id="L822">    log.debug(&quot;Annealing: annealing&quot;);</span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">    while (currentTemperature &gt; endTemperature) {</span>
<span class="fc" id="L824">      int[] routeCandidate =</span>
<span class="fc" id="L825">          generateCandidate(route, n, from, loadingCities, unloadingCities, cycleDetected);</span>
<span class="fc" id="L826">      int candidateEnergy = calculateEnergy(routeCandidate, matr);</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">      if (candidateEnergy &lt; currentEnergy) {</span>
<span class="fc" id="L828">        currentEnergy = candidateEnergy;</span>
<span class="fc" id="L829">        route = routeCandidate;</span>
      } else {
<span class="fc" id="L831">        double p = getTranstionProbability(candidateEnergy - currentEnergy, currentTemperature);</span>
<span class="fc bfc" id="L832" title="All 2 branches covered.">        if (makeTransit(p)) {</span>
<span class="fc" id="L833">          currentEnergy = candidateEnergy;</span>
<span class="fc" id="L834">          route = routeCandidate;</span>
        }
      }
<span class="fc" id="L837">      currentTemperature = decreaseTemperature(initialTemperature, k);</span>
      // log.debug(&quot;k = &quot; + k + &quot;; T = &quot; + currentTemperature);
<span class="fc" id="L839">      k++;</span>
<span class="fc" id="L840">    }</span>
<span class="fc" id="L841">    log.debug(&quot;Annealing ended&quot;);</span>
<span class="fc" id="L842">    return route;</span>
  }

  /**
   * Utility method to calculate &quot;energy&quot; of current route.
   * 
   * @param route route for calculating energy
   * @param matr matrix of distances between cities
   * @return energy amount
   */
  private int calculateEnergy(int[] route, int[][] matr) {
<span class="fc" id="L853">    int n = route.length;</span>
<span class="fc" id="L854">    int energy = 0;</span>
<span class="fc bfc" id="L855" title="All 2 branches covered.">    for (int i = 0; i &lt; n - 1; i++) {</span>
<span class="fc" id="L856">      energy += matr[route[i]][route[i + 1]];</span>
    }
<span class="fc" id="L858">    return energy;</span>
  }

  /**
   * Utility method for generating new candidate based on previous state.
   * 
   * @param previousState previous state for generating new state
   * @param n state length
   * @param from city index to start from
   * @param loadingCities list of loading cities
   * @param unloadingCities list of unloading cities
   * @param cycleDetected flag which indicates if cycle detected. Used to alter generation
   *        conditions for cycled case.
   * @return new route state
   */
  private int[] generateCandidate(int[] previousState, int n, int from, List&lt;Integer&gt; loadingCities,
      List&lt;Integer&gt; unloadingCities, boolean cycleDetected) {
<span class="fc" id="L875">    List&lt;Integer&gt; state = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L876" title="All 2 branches covered.">    for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L877">      state.add(previousState[i]);</span>
    }
<span class="fc" id="L879">    boolean sequenceCorrect = false;</span>
<span class="fc bfc" id="L880" title="All 2 branches covered.">    while (!sequenceCorrect) {</span>
<span class="fc" id="L881">      Collections.shuffle(state);</span>
<span class="fc" id="L882">      state.set(state.indexOf(from), state.get(0));</span>
<span class="fc" id="L883">      state.set(0, from);</span>
<span class="fc" id="L884">      sequenceCorrect = true;</span>
<span class="fc bfc" id="L885" title="All 2 branches covered.">      if (!cycleDetected) {</span>
<span class="fc bfc" id="L886" title="All 2 branches covered.">        for (int i = 0; i &lt; loadingCities.size(); i++) {</span>
<span class="fc" id="L887">          sequenceCorrect &amp;=</span>
<span class="fc bfc" id="L888" title="All 2 branches covered.">              state.indexOf(loadingCities.get(i)) &lt; state.indexOf(unloadingCities.get(i));</span>
        }
      } else {
<span class="fc" id="L891">        adaptCandidateForCycleProcessing(state, loadingCities, unloadingCities);</span>
      }
    }
<span class="fc" id="L894">    int[] newState = new int[state.size()];</span>
<span class="fc bfc" id="L895" title="All 2 branches covered.">    for (int i = 0; i &lt; newState.length; i++) {</span>
<span class="fc" id="L896">      newState[i] = state.get(i);</span>
    }
<span class="fc" id="L898">    return newState;</span>
  }

  /**
   * Calculates probability of changing state to generated (even if its energy is higher than
   * current).
   * 
   * @param energy current state energy
   * @param temperature current temperature
   * @return probability of state change
   */
  private double getTranstionProbability(int energy, double temperature) {
<span class="fc" id="L910">    return 1 / (1 + Math.exp(energy / temperature));</span>
  }

  /**
   * Decides whether to change state or not, based on given probability.
   * 
   * @param probability probability of transit
   * @return true if state should be changed, else otherwise
   */
  private boolean makeTransit(double probability) {
<span class="fc bfc" id="L920" title="All 2 branches covered.">    return Math.random() &lt;= probability;</span>
  }

  /**
   * Utility function to decrease current temperature.
   * 
   * @param initialTemperature staring temperature
   * @param k iteration counter
   * @return decreased temperature
   */
  private double decreaseTemperature(double initialTemperature, int k) {
<span class="fc" id="L931">    return initialTemperature / Math.log(1.0 + k);</span>
  }

  /**
   * Utility method, required for solving cycles when generating candidate.
   * 
   * @param routeList route list
   * @param loadingCities list of loading cities
   * @param unloadingCities list of unloading cities
   */
  private void adaptCandidateForCycleProcessing(List&lt;Integer&gt; routeList,
      List&lt;Integer&gt; loadingCities, List&lt;Integer&gt; unloadingCities) {
<span class="fc" id="L943">    boolean[] loaded = new boolean[loadingCities.size()];</span>
<span class="fc" id="L944">    boolean[] unloaded = new boolean[unloadingCities.size()];</span>
<span class="fc bfc" id="L945" title="All 2 branches covered.">    for (int i = 0; i &lt; routeList.size(); i++) {</span>
<span class="fc bfc" id="L946" title="All 2 branches covered.">      for (int j = 0; j &lt; loadingCities.size(); j++) {</span>
<span class="fc bfc" id="L947" title="All 2 branches covered.">        if (loadingCities.get(j).equals(routeList.get(i))) {</span>
<span class="fc" id="L948">          loaded[j] = true;</span>
        }
      }
<span class="fc bfc" id="L951" title="All 2 branches covered.">      for (int j = 0; j &lt; unloadingCities.size(); j++) {</span>
<span class="fc bfc" id="L952" title="All 4 branches covered.">        if (unloadingCities.get(j).equals(routeList.get(i)) &amp;&amp; loaded[j]) {</span>
<span class="fc" id="L953">          unloaded[j] = true;</span>
        }
      }
    }
<span class="fc" id="L957">    List&lt;Integer&gt; leftCities = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L958" title="All 2 branches covered.">    for (int i = 0; i &lt; unloaded.length; i++) {</span>
<span class="fc bfc" id="L959" title="All 2 branches covered.">      if (!unloaded[i]) {</span>
<span class="fc" id="L960">        leftCities.add(unloadingCities.get(i));</span>
      }
    }
<span class="fc" id="L963">    Collections.shuffle(leftCities);</span>
<span class="fc bfc" id="L964" title="All 2 branches covered.">    for (int i = 0; i &lt; leftCities.size(); i++) {</span>
<span class="fc" id="L965">      routeList.add(leftCities.get(i));</span>
    }
<span class="fc" id="L967">  }</span>

  /**
   * Creates and fills matrix.
   * 
   * @param n matrix size
   * @return matrix filled with {@linkplain Integer#MAX_VALUE Integer.MAX_VALUE} / 2
   */
  private int[][] buildMatrix(int n) {
<span class="fc" id="L976">    int[][] matrix = new int[n][n];</span>
<span class="fc bfc" id="L977" title="All 2 branches covered.">    for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L978" title="All 2 branches covered.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L979">        matrix[i][j] = Integer.MAX_VALUE / 2;</span>
      }
    }
<span class="fc" id="L982">    return matrix;</span>
  }

  /**
   * Fills given matrix with given city distances.
   * 
   * @param matrix matrix to fill
   * @param distances list of distances between cities
   * @param cityNames list of city names
   */
  private void fillMatrixWithDefaultCityDistances(int[][] matrix, List&lt;CityDistance&gt; distances,
      List&lt;String&gt; cityNames) {
<span class="fc bfc" id="L994" title="All 2 branches covered.">    for (CityDistance cd : distances) {</span>
<span class="fc" id="L995">      int i = cityNames.indexOf(cd.getCityA());</span>
<span class="fc" id="L996">      int j = cityNames.indexOf(cd.getCityB());</span>
<span class="fc" id="L997">      matrix[i][j] = cd.getDistance();</span>
<span class="fc" id="L998">      matrix[j][i] = cd.getDistance();</span>
<span class="fc" id="L999">    }</span>
<span class="fc" id="L1000">  }</span>

  /**
   * Fills matrix with calculated path between cities which are not connected directly.
   * 
   * @param matrix matrix of selected cities
   * @param bigMatrix matrix of distances between cities
   * @param cityNames list of city names
   * @param rpCities list of route point cities
   */
  private void resolvePathsForMatrix(int[][] matrix, int[][] bigMatrix, List&lt;String&gt; cityNames,
      List&lt;City&gt; rpCities) {
<span class="fc" id="L1012">    int n = matrix.length;</span>
<span class="fc bfc" id="L1013" title="All 2 branches covered.">    for (int i = 0; i &lt; n; i++) {</span>
<span class="fc bfc" id="L1014" title="All 2 branches covered.">      for (int j = i + 1; j &lt; n; j++) {</span>
<span class="fc" id="L1015">        int k = cityNames.indexOf(rpCities.get(i).getCurrentCity());</span>
<span class="fc" id="L1016">        int m = cityNames.indexOf(rpCities.get(j).getCurrentCity());</span>
<span class="fc bfc" id="L1017" title="All 2 branches covered.">        if (bigMatrix[k][m] != Integer.MAX_VALUE / 2) {</span>
<span class="fc" id="L1018">          matrix[i][j] = bigMatrix[k][m];</span>
<span class="fc" id="L1019">          matrix[j][i] = bigMatrix[k][m];</span>
        } else {
<span class="fc" id="L1021">          List&lt;Integer&gt; route = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1022">          log.info(&quot;Trying to calulate path between &quot; + rpCities.get(i).getCurrentCity() + &quot; and &quot;</span>
<span class="fc" id="L1023">              + rpCities.get(j).getCurrentCity());</span>
<span class="fc" id="L1024">          int value = getShortestPath(bigMatrix, route, k, m);</span>
<span class="fc" id="L1025">          matrix[i][j] = value;</span>
<span class="fc" id="L1026">          matrix[j][i] = value;</span>
<span class="fc" id="L1027">          String path = &quot;&quot;;</span>
<span class="fc bfc" id="L1028" title="All 2 branches covered.">          for (Integer x : route) {</span>
<span class="fc" id="L1029">            path += x + &quot; &quot;;</span>
<span class="fc" id="L1030">          }</span>
<span class="fc" id="L1031">          log.debug(path);</span>
        }
      }
    }
<span class="fc" id="L1035">  }</span>

  /**
   * Method which will assign drivers for given path and car. The best solution is counted as one
   * driver for whole path.
   * 
   * @param path calculated path
   * @param matrix matrix of distances between cities
   * @param rpCities route points cities
   * @param selectedCar selected cars
   * @param session active session for persisting entities with lazy fetch type
   * @return list of drivers available for assigning to order
   */
  private List&lt;User&gt; tryToAssignDriversForOrder(String path, int[][] matrix, List&lt;City&gt; rpCities,
      Car selectedCar) {
<span class="pc bpc" id="L1050" title="1 of 2 branches missed.">    if (selectedCar == null) {</span>
<span class="nc" id="L1051">      return null;</span>
    }
    // delimeter is ' '
<span class="fc" id="L1054">    final String delimeter = &quot; &quot;;</span>
<span class="fc" id="L1055">    List&lt;String&gt; cityNames =</span>
<span class="fc" id="L1056">        rpCities.stream().map(c -&gt; c.getCurrentCity()).collect(Collectors.toList());</span>
<span class="fc" id="L1057">    log.debug(cityNames.toString());</span>
<span class="fc" id="L1058">    String[] cities = path.split(delimeter);</span>
<span class="fc" id="L1059">    final int n = cities.length;</span>
<span class="fc" id="L1060">    int[] distances = new int[n - 1];</span>
    // list of capable drivers from each city on route
<span class="fc" id="L1062">    List&lt;List&lt;User&gt;&gt; drivers = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1063" title="All 2 branches covered.">    for (int i = 0; i &lt; n - 1; i++) {</span>
<span class="fc" id="L1064">      int indexCurrentCity = cityNames.indexOf(cities[i]);</span>
<span class="fc" id="L1065">      int indexNextCity = cityNames.indexOf(cities[i + 1]);</span>
<span class="fc" id="L1066">      distances[i] = matrix[indexCurrentCity][indexNextCity];</span>
      // adding drivers
<span class="fc" id="L1068">      List&lt;User&gt; cityDrivers = rpCities.get(indexCurrentCity).getUserInfos().stream()</span>
<span class="fc" id="L1069">          .map(ui -&gt; ui.getUser()).filter(this::isDriverCapable).collect(Collectors.toList());</span>
<span class="fc" id="L1070">      drivers.add(i, cityDrivers);</span>
    }
<span class="fc" id="L1072">    log.debug(drivers.toString());</span>
    // counter for list of drivers for each city
<span class="fc" id="L1074">    int[] counters = new int[n - 1];</span>
<span class="fc" id="L1075">    int currentCityIndex = 0;</span>
<span class="fc" id="L1076">    int selectedDriverCity = 0;</span>
<span class="fc" id="L1077">    int hoursAtDriving = 0;</span>
<span class="fc" id="L1078">    List&lt;User&gt; driversChain = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1079">    List&lt;Calendar&gt; calendarChain = new ArrayList&lt;&gt;();</span>
    User driver;
<span class="fc" id="L1081">    Calendar calendar = new GregorianCalendar();</span>
<span class="fc" id="L1082">    calendarChain.add(calendar);</span>
<span class="fc bfc" id="L1083" title="All 4 branches covered.">    while (currentCityIndex != n - 1 &amp;&amp; counters[0] &lt; drivers.get(0).size()) {</span>
<span class="fc" id="L1084">      log.debug(driversChain.toString());</span>
<span class="pc bpc" id="L1085" title="1 of 2 branches missed.">      if (counters[selectedDriverCity] &lt; drivers.get(selectedDriverCity).size()) {</span>
<span class="fc" id="L1086">        log.debug(&quot;Selecting driver&quot;);</span>
<span class="fc" id="L1087">        driver = drivers.get(selectedDriverCity).get(counters[selectedDriverCity]);</span>
      } else {
<span class="nc" id="L1089">        log.debug(&quot;Deleting last entry from chain&quot;);</span>
        /*
         * for(int i = 0; i &lt; drivers.size(); i++) {
         * if(drivers.get(i).contains(driversChain.get(driversChain.size() - 1))) {
         * selectedDriverCity = i; currentCityIndex = i; break; } }
         */
<span class="nc" id="L1095">        currentCityIndex--;</span>
<span class="nc" id="L1096">        selectedDriverCity = currentCityIndex;</span>
<span class="nc" id="L1097">        driversChain.remove(driversChain.size() - 1);</span>
<span class="nc" id="L1098">        calendarChain.remove(calendarChain.size() - 1);</span>
<span class="nc" id="L1099">        calendar = calendarChain.get(calendarChain.size() - 1);</span>
<span class="nc" id="L1100">        counters[selectedDriverCity]++;</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">        for (int i = selectedDriverCity + 1; i &lt; counters.length; i++) {</span>
<span class="nc" id="L1102">          counters[i] = 0;</span>
        }
<span class="nc" id="L1104">        continue;</span>
      }
<span class="fc" id="L1106">      int hoursToNextCity =</span>
<span class="fc" id="L1107">          (int) Math.round((double) distances[currentCityIndex] / AVERAGE_CAR_SPEED);</span>
<span class="fc" id="L1108">      log.debug(hoursToNextCity);</span>
<span class="fc" id="L1109">      hoursAtDriving += hoursToNextCity;</span>
<span class="fc" id="L1110">      log.debug(hoursAtDriving);</span>
<span class="fc" id="L1111">      Calendar copy = (Calendar) calendar.clone();</span>
<span class="fc" id="L1112">      copy.add(Calendar.HOUR_OF_DAY, hoursToNextCity);</span>
<span class="fc" id="L1113">      int hoursWorked = driver.getUserInfo().getHoursWorked();</span>
<span class="pc bpc" id="L1114" title="1 of 2 branches missed.">      if (copy.get(Calendar.MONTH) != calendar.get(Calendar.MONTH)) {</span>
<span class="nc" id="L1115">        hoursWorked = copy.get(Calendar.HOUR_OF_DAY);</span>
      }
<span class="fc" id="L1117">      calendar = copy;</span>
<span class="pc bpc" id="L1118" title="1 of 2 branches missed.">      boolean hasTime = hoursWorked + hoursAtDriving &lt;= MONTH_HOURS_LIMIT;</span>
<span class="fc bfc" id="L1119" title="All 2 branches covered.">      boolean isCarShiftLengthCapacityReached = hoursAtDriving &gt; selectedCar.getShiftLength();</span>
<span class="fc" id="L1120">      log.debug(hasTime + &quot;;&quot; + isCarShiftLengthCapacityReached);</span>
<span class="pc bpc" id="L1121" title="1 of 4 branches missed.">      if (hasTime &amp;&amp; !isCarShiftLengthCapacityReached) {</span>
<span class="fc" id="L1122">        log.debug(&quot;Adding driver to chain&quot;);</span>
<span class="fc" id="L1123">        currentCityIndex++;</span>
<span class="fc" id="L1124">        driversChain.add(driver);</span>
<span class="fc" id="L1125">        calendarChain.add(calendar);</span>
      } else {
<span class="fc" id="L1127">        hoursAtDriving = 0;</span>
<span class="fc bfc" id="L1128" title="All 2 branches covered.">        if (selectedDriverCity != currentCityIndex) {</span>
<span class="fc" id="L1129">          log.debug(&quot;City has changed&quot;);</span>
<span class="fc" id="L1130">          selectedDriverCity = currentCityIndex;</span>
        } else {
<span class="fc" id="L1132">          log.debug(&quot;City hasn't changed, switching to next driver&quot;);</span>
<span class="fc" id="L1133">          counters[selectedDriverCity]++;</span>
        }
      }
<span class="fc" id="L1136">    }</span>
<span class="fc bfc" id="L1137" title="All 2 branches covered.">    return currentCityIndex == n - 1 ? driversChain : null;</span>
  }

  /**
   * Checks if driver capable of driving (i.e. driver is on shift, has no assigned order and user is
   * driver)
   * 
   * @param user user to check
   * @return true if user can be used for driving for given order, false otherwise
   */
  private boolean isDriverCapable(User user) {
<span class="fc" id="L1148">    boolean isDriver = user.getRole().equalsIgnoreCase(UserRole.DRIVER.toString());</span>
<span class="pc bpc" id="L1149" title="1 of 2 branches missed.">    log.debug(user.getUserInfo() != null ? user.getUserInfo().toString() : &quot;null&quot;);</span>
<span class="fc" id="L1150">    boolean isOnShift =</span>
<span class="fc" id="L1151">        user.getUserInfo().getStatus().equalsIgnoreCase(DriverStatus.ON_SHIFT.toString());</span>
<span class="fc bfc" id="L1152" title="All 2 branches covered.">    boolean hasAssignedOrder = user.getUserInfo().getOrder() != null;</span>
<span class="pc bpc" id="L1153" title="1 of 6 branches missed.">    return isDriver &amp;&amp; isOnShift &amp;&amp; !hasAssignedOrder;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>